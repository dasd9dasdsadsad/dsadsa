name: MCP 100 Workers - 5 Jobs x 20 Containers Each

on:
  workflow_dispatch:
    inputs:
      job_id:
        description: 'Job ID (1-5)'
        required: true
        default: '1'
      base_url:
        description: 'Base URL to visit'
        required: false
        default: 'asdfazrcdfgqoiuibvkf934exsjcoluvq.oast.fun'

env:
  MANAGER_HOST: 165.232.134.47
  NATS_HOST: 165.232.134.47
  NATS_PORT: 4222
  REDIS_HOST: 165.232.134.47
  REDIS_PORT: 6379
  POSTGRES_HOST: 165.232.134.47
  POSTGRES_PORT: 5432
  POSTGRES_DB: mcp_manager
  POSTGRES_USER: postgres
  POSTGRES_PASSWORD: postgres
  DOCKER_IMAGE: test123434sdd/mcp-remote-worker:latest

jobs:
  spawn-20-containers:
    runs-on: ubuntu-latest
    timeout-minutes: 360  # 6 hours - unlimited timeout
    
    steps:
      - name: ğŸ” Checkout code
        uses: actions/checkout@v4

      - name: ğŸ”‘ Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: test123434sdd
          password: ${{ secrets.DOCKER_TOKEN }}

      - name: ğŸŒ Test Connectivity
        run: |
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸŒ Job ${{ github.event.inputs.job_id }} - Testing Connection"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          
          if nc -zv -w5 ${{ env.NATS_HOST }} ${{ env.NATS_PORT }} 2>&1; then
            echo "âœ… NATS: Connected"
          else
            echo "âŒ NATS: Cannot connect"
            exit 1
          fi

      - name: ğŸ³ Pull Worker Docker Image
        run: |
          echo "ğŸ“¥ Pulling Docker image..."
          docker pull ${{ env.DOCKER_IMAGE }}

      - name: ğŸš€ Spawn 20 Docker Containers
        run: |
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸš€ Spawning 20 Workers for Job ${{ github.event.inputs.job_id }}"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          
          JOB_ID="${{ github.event.inputs.job_id }}"
          RUN_ID="${{ github.run_id }}"
          BASE_URL="${{ github.event.inputs.base_url }}"
          
          # Spawn 20 containers in parallel
          for i in {1..20}; do
            WORKER_NAME="worker-job${JOB_ID}-container${i}-${RUN_ID}"
            WORKER_ID="worker-j${JOB_ID}-c${i}-${RUN_ID}"
            
            echo "Starting container $i/20: $WORKER_ID"
            
            docker run -d \
              --name $WORKER_NAME \
              -e WORKER_ID="$WORKER_ID" \
              -e WORKER_TAGS="job-${JOB_ID},container-${i},run-${RUN_ID},100-workers" \
              -e MANAGER_HOST="${{ env.MANAGER_HOST }}" \
              -e NATS_HOST="${{ env.NATS_HOST }}" \
              -e NATS_PORT="${{ env.NATS_PORT }}" \
              -e REDIS_HOST="${{ env.REDIS_HOST }}" \
              -e REDIS_PORT="${{ env.REDIS_PORT }}" \
              -e POSTGRES_HOST="${{ env.POSTGRES_HOST }}" \
              -e POSTGRES_PORT="${{ env.POSTGRES_PORT }}" \
              -e POSTGRES_DB="${{ env.POSTGRES_DB }}" \
              -e POSTGRES_USER="${{ env.POSTGRES_USER }}" \
              -e POSTGRES_PASSWORD="${{ env.POSTGRES_PASSWORD }}" \
              ${{ env.DOCKER_IMAGE }} &
            
            # Small delay to avoid overwhelming the system
            sleep 0.5
          done
          
          # Wait for all containers to start
          echo ""
          echo "â³ Waiting for all containers to start..."
          sleep 30
          
          echo ""
          echo "âœ… All 20 containers spawned!"
          docker ps | grep "worker-job${JOB_ID}" | wc -l

      - name: ğŸ“Š Monitor Workers
        run: |
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸ“Š Monitoring 20 Workers - Job ${{ github.event.inputs.job_id }}"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          
          JOB_ID="${{ github.event.inputs.job_id }}"
          RUN_ID="${{ github.run_id }}"
          
          # Monitor for 5 hours (unlimited timeout)
          END_TIME=$(($(date +%s) + 18000))
          
          while [ $(date +%s) -lt $END_TIME ]; do
            RUNNING=$(docker ps | grep "worker-job${JOB_ID}" | wc -l)
            echo "[$(date '+%H:%M:%S')] Job ${JOB_ID}: $RUNNING/20 containers running"
            
            # Check if all containers stopped (tasks completed)
            if [ $RUNNING -eq 0 ]; then
              echo "âœ… All containers completed their tasks"
              break
            fi
            
            sleep 60
          done

      - name: ğŸ“ Summary
        if: always()
        run: |
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸ“ Job ${{ github.event.inputs.job_id }} Summary"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "Run ID: ${{ github.run_id }}"
          echo "Job ID: ${{ github.event.inputs.job_id }}"
          echo "Containers: 20"
          echo "Runtime: ${SECONDS} seconds"

      - name: ğŸ›‘ Cleanup
        if: always()
        run: |
          JOB_ID="${{ github.event.inputs.job_id }}"
          echo "ğŸ›‘ Cleaning up all containers for Job ${JOB_ID}..."
          docker ps -a | grep "worker-job${JOB_ID}" | awk '{print $1}' | xargs -r docker stop
          docker ps -a | grep "worker-job${JOB_ID}" | awk '{print $1}' | xargs -r docker rm
          echo "âœ… Cleanup complete"

